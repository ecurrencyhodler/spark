// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lrc20.proto

package lrc20

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SendSparkSignatureRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendSparkSignatureRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendSparkSignatureRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendSparkSignatureRequestMultiError, or nil if none found.
func (m *SendSparkSignatureRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SendSparkSignatureRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendSparkSignatureRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendSparkSignatureRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendSparkSignatureRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOperatorSpecificSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SendSparkSignatureRequestValidationError{
						field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SendSparkSignatureRequestValidationError{
						field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SendSparkSignatureRequestValidationError{
					field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOperatorSignatureData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendSparkSignatureRequestValidationError{
					field:  "OperatorSignatureData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendSparkSignatureRequestValidationError{
					field:  "OperatorSignatureData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorSignatureData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendSparkSignatureRequestValidationError{
				field:  "OperatorSignatureData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRevocationSecrets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SendSparkSignatureRequestValidationError{
						field:  fmt.Sprintf("RevocationSecrets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SendSparkSignatureRequestValidationError{
						field:  fmt.Sprintf("RevocationSecrets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SendSparkSignatureRequestValidationError{
					field:  fmt.Sprintf("RevocationSecrets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SendSparkSignatureRequestMultiError(errors)
	}

	return nil
}

// SendSparkSignatureRequestMultiError is an error wrapping multiple validation
// errors returned by SendSparkSignatureRequest.ValidateAll() if the
// designated constraints aren't met.
type SendSparkSignatureRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendSparkSignatureRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendSparkSignatureRequestMultiError) AllErrors() []error { return m }

// SendSparkSignatureRequestValidationError is the validation error returned by
// SendSparkSignatureRequest.Validate if the designated constraints aren't met.
type SendSparkSignatureRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendSparkSignatureRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendSparkSignatureRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendSparkSignatureRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendSparkSignatureRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendSparkSignatureRequestValidationError) ErrorName() string {
	return "SendSparkSignatureRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendSparkSignatureRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendSparkSignatureRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendSparkSignatureRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendSparkSignatureRequestValidationError{}

// Validate checks the field values on SparkOperatorSignatureData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SparkOperatorSignatureData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SparkOperatorSignatureData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SparkOperatorSignatureDataMultiError, or nil if none found.
func (m *SparkOperatorSignatureData) ValidateAll() error {
	return m.validate(true)
}

func (m *SparkOperatorSignatureData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetSparkOperatorSignature()); l < 64 || l > 73 {
		err := SparkOperatorSignatureDataValidationError{
			field:  "SparkOperatorSignature",
			reason: "value length must be between 64 and 73 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetOperatorIdentityPublicKey()) != 33 {
		err := SparkOperatorSignatureDataValidationError{
			field:  "OperatorIdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SparkOperatorSignatureDataMultiError(errors)
	}

	return nil
}

// SparkOperatorSignatureDataMultiError is an error wrapping multiple
// validation errors returned by SparkOperatorSignatureData.ValidateAll() if
// the designated constraints aren't met.
type SparkOperatorSignatureDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SparkOperatorSignatureDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SparkOperatorSignatureDataMultiError) AllErrors() []error { return m }

// SparkOperatorSignatureDataValidationError is the validation error returned
// by SparkOperatorSignatureData.Validate if the designated constraints aren't met.
type SparkOperatorSignatureDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SparkOperatorSignatureDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SparkOperatorSignatureDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SparkOperatorSignatureDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SparkOperatorSignatureDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SparkOperatorSignatureDataValidationError) ErrorName() string {
	return "SparkOperatorSignatureDataValidationError"
}

// Error satisfies the builtin error interface
func (e SparkOperatorSignatureDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSparkOperatorSignatureData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SparkOperatorSignatureDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SparkOperatorSignatureDataValidationError{}

// Validate checks the field values on SparkSignatureOutputData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SparkSignatureOutputData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SparkSignatureOutputData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SparkSignatureOutputDataMultiError, or nil if none found.
func (m *SparkSignatureOutputData) ValidateAll() error {
	return m.validate(true)
}

func (m *SparkSignatureOutputData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpentOutputIndex

	if m.RevocationPrivateKey != nil {
		// no validation rules for RevocationPrivateKey
	}

	if len(errors) > 0 {
		return SparkSignatureOutputDataMultiError(errors)
	}

	return nil
}

// SparkSignatureOutputDataMultiError is an error wrapping multiple validation
// errors returned by SparkSignatureOutputData.ValidateAll() if the designated
// constraints aren't met.
type SparkSignatureOutputDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SparkSignatureOutputDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SparkSignatureOutputDataMultiError) AllErrors() []error { return m }

// SparkSignatureOutputDataValidationError is the validation error returned by
// SparkSignatureOutputData.Validate if the designated constraints aren't met.
type SparkSignatureOutputDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SparkSignatureOutputDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SparkSignatureOutputDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SparkSignatureOutputDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SparkSignatureOutputDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SparkSignatureOutputDataValidationError) ErrorName() string {
	return "SparkSignatureOutputDataValidationError"
}

// Error satisfies the builtin error interface
func (e SparkSignatureOutputDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSparkSignatureOutputData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SparkSignatureOutputDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SparkSignatureOutputDataValidationError{}

// Validate checks the field values on GetSparkTxRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSparkTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSparkTxRequestMultiError, or nil if none found.
func (m *GetSparkTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSparkTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FinalTokenTransactionHash

	if len(errors) > 0 {
		return GetSparkTxRequestMultiError(errors)
	}

	return nil
}

// GetSparkTxRequestMultiError is an error wrapping multiple validation errors
// returned by GetSparkTxRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSparkTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSparkTxRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSparkTxRequestMultiError) AllErrors() []error { return m }

// GetSparkTxRequestValidationError is the validation error returned by
// GetSparkTxRequest.Validate if the designated constraints aren't met.
type GetSparkTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSparkTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSparkTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSparkTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSparkTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSparkTxRequestValidationError) ErrorName() string {
	return "GetSparkTxRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSparkTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSparkTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSparkTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSparkTxRequestValidationError{}

// Validate checks the field values on VerifySparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerifySparkTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifySparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifySparkTxRequestMultiError, or nil if none found.
func (m *VerifySparkTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifySparkTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifySparkTxRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifySparkTxRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifySparkTxRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerifySparkTxRequestMultiError(errors)
	}

	return nil
}

// VerifySparkTxRequestMultiError is an error wrapping multiple validation
// errors returned by VerifySparkTxRequest.ValidateAll() if the designated
// constraints aren't met.
type VerifySparkTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifySparkTxRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifySparkTxRequestMultiError) AllErrors() []error { return m }

// VerifySparkTxRequestValidationError is the validation error returned by
// VerifySparkTxRequest.Validate if the designated constraints aren't met.
type VerifySparkTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifySparkTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifySparkTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifySparkTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifySparkTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifySparkTxRequestValidationError) ErrorName() string {
	return "VerifySparkTxRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VerifySparkTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifySparkTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifySparkTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifySparkTxRequestValidationError{}

// Validate checks the field values on ListSparkTxsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSparkTxsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSparkTxsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSparkTxsRequestMultiError, or nil if none found.
func (m *ListSparkTxsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSparkTxsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListSparkTxsRequestMultiError(errors)
	}

	return nil
}

// ListSparkTxsRequestMultiError is an error wrapping multiple validation
// errors returned by ListSparkTxsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListSparkTxsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSparkTxsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSparkTxsRequestMultiError) AllErrors() []error { return m }

// ListSparkTxsRequestValidationError is the validation error returned by
// ListSparkTxsRequest.Validate if the designated constraints aren't met.
type ListSparkTxsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSparkTxsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSparkTxsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSparkTxsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSparkTxsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSparkTxsRequestValidationError) ErrorName() string {
	return "ListSparkTxsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSparkTxsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSparkTxsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSparkTxsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSparkTxsRequestValidationError{}

// Validate checks the field values on ListSparkTxsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSparkTxsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSparkTxsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSparkTxsResponseMultiError, or nil if none found.
func (m *ListSparkTxsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSparkTxsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokenTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSparkTxsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSparkTxsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSparkTxsResponseValidationError{
					field:  fmt.Sprintf("TokenTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NextPageToken != nil {
		// no validation rules for NextPageToken
	}

	if len(errors) > 0 {
		return ListSparkTxsResponseMultiError(errors)
	}

	return nil
}

// ListSparkTxsResponseMultiError is an error wrapping multiple validation
// errors returned by ListSparkTxsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListSparkTxsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSparkTxsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSparkTxsResponseMultiError) AllErrors() []error { return m }

// ListSparkTxsResponseValidationError is the validation error returned by
// ListSparkTxsResponse.Validate if the designated constraints aren't met.
type ListSparkTxsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSparkTxsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSparkTxsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSparkTxsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSparkTxsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSparkTxsResponseValidationError) ErrorName() string {
	return "ListSparkTxsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSparkTxsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSparkTxsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSparkTxsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSparkTxsResponseValidationError{}

// Validate checks the field values on GetSparkTxResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSparkTxResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSparkTxResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSparkTxResponseMultiError, or nil if none found.
func (m *GetSparkTxResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSparkTxResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSparkTxResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSparkTxResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSparkTxResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSparkTxResponseMultiError(errors)
	}

	return nil
}

// GetSparkTxResponseMultiError is an error wrapping multiple validation errors
// returned by GetSparkTxResponse.ValidateAll() if the designated constraints
// aren't met.
type GetSparkTxResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSparkTxResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSparkTxResponseMultiError) AllErrors() []error { return m }

// GetSparkTxResponseValidationError is the validation error returned by
// GetSparkTxResponse.Validate if the designated constraints aren't met.
type GetSparkTxResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSparkTxResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSparkTxResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSparkTxResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSparkTxResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSparkTxResponseValidationError) ErrorName() string {
	return "GetSparkTxResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSparkTxResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSparkTxResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSparkTxResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSparkTxResponseValidationError{}

// Validate checks the field values on TokenTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionResponseMultiError, or nil if none found.
func (m *TokenTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Finalized

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenTransactionResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TokenTransactionResponseMultiError(errors)
	}

	return nil
}

// TokenTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by TokenTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type TokenTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionResponseMultiError) AllErrors() []error { return m }

// TokenTransactionResponseValidationError is the validation error returned by
// TokenTransactionResponse.Validate if the designated constraints aren't met.
type TokenTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionResponseValidationError) ErrorName() string {
	return "TokenTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionResponseValidationError{}

// Validate checks the field values on ListWithdrawnOutputsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWithdrawnOutputsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWithdrawnOutputsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWithdrawnOutputsRequestMultiError, or nil if none found.
func (m *ListWithdrawnOutputsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWithdrawnOutputsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Blockhash != nil {
		// no validation rules for Blockhash
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListWithdrawnOutputsRequestMultiError(errors)
	}

	return nil
}

// ListWithdrawnOutputsRequestMultiError is an error wrapping multiple
// validation errors returned by ListWithdrawnOutputsRequest.ValidateAll() if
// the designated constraints aren't met.
type ListWithdrawnOutputsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWithdrawnOutputsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWithdrawnOutputsRequestMultiError) AllErrors() []error { return m }

// ListWithdrawnOutputsRequestValidationError is the validation error returned
// by ListWithdrawnOutputsRequest.Validate if the designated constraints
// aren't met.
type ListWithdrawnOutputsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWithdrawnOutputsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWithdrawnOutputsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWithdrawnOutputsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWithdrawnOutputsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWithdrawnOutputsRequestValidationError) ErrorName() string {
	return "ListWithdrawnOutputsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWithdrawnOutputsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWithdrawnOutputsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWithdrawnOutputsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWithdrawnOutputsRequestValidationError{}

// Validate checks the field values on ListWithdrawnOutputsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWithdrawnOutputsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWithdrawnOutputsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWithdrawnOutputsResponseMultiError, or nil if none found.
func (m *ListWithdrawnOutputsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWithdrawnOutputsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWithdrawnOutputsResponseValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWithdrawnOutputsResponseValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWithdrawnOutputsResponseValidationError{
					field:  fmt.Sprintf("Outputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NextPageToken != nil {
		// no validation rules for NextPageToken
	}

	if len(errors) > 0 {
		return ListWithdrawnOutputsResponseMultiError(errors)
	}

	return nil
}

// ListWithdrawnOutputsResponseMultiError is an error wrapping multiple
// validation errors returned by ListWithdrawnOutputsResponse.ValidateAll() if
// the designated constraints aren't met.
type ListWithdrawnOutputsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWithdrawnOutputsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWithdrawnOutputsResponseMultiError) AllErrors() []error { return m }

// ListWithdrawnOutputsResponseValidationError is the validation error returned
// by ListWithdrawnOutputsResponse.Validate if the designated constraints
// aren't met.
type ListWithdrawnOutputsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWithdrawnOutputsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWithdrawnOutputsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWithdrawnOutputsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWithdrawnOutputsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWithdrawnOutputsResponseValidationError) ErrorName() string {
	return "ListWithdrawnOutputsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWithdrawnOutputsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWithdrawnOutputsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWithdrawnOutputsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWithdrawnOutputsResponseValidationError{}
